# Wrap Offset（レイヤーラップスクロール）

## Context

パターン作成ツールとしてアプリを使う場合、タイルの繋ぎ目部分を編集しやすくするために、レイヤーの表示をオフセット（ラップスクロール）する機能が必要。Photoshopの「フィルター→その他→スクロール」に相当する機能。

**問題**: 繋ぎ目はレイヤーの端に位置するため、直接編集しにくい
**解決**: オフセットで繋ぎ目をレイヤー中央に移動して編集可能にする

## アプローチ: 表示オフセット + 入力座標変換 + 境界分割

3つの却下案と採用案:

| アプローチ | 概要 | 判定 |
|---|---|---|
| ピクセルシフト | オフセット変更時にピクセルデータをコピー | 却下: 破壊的・非効率 |
| 4コピー描画 | ctx.translateでオフセット適用し4回描画 | 却下: オフセット変更にフル再レンダリング必要 |
| ViewTransformに統合 | オフセットをViewTransformに含める | 却下: ラッピングと相性が悪い |
| **表示オフセット + 入力変換 + 分割** | 表示は4コピー合成、入力は座標変換、描画は物理座標に分割描画 | **採用** |

### 採用案の原理

```
入力: screenToLayer → applyWrapOffset(visual→physical座標) → FilterPipeline → Session
描画: Expand → wrapToLayer(modulo) → splitAtBoundary → drawVariableWidthPath
表示: renderLayersで4コピー合成（表示のみ、物理キャンバス不変）
UI:   SymmetryOverlayのガイド位置をoffsetで調整
```

**核心**: 物理キャンバスの内容はオフセットに依存しない。各ストロークは描画時のオフセットで物理座標に変換されるが、キャンバス上のピクセルはオフセットの一部ではない。**オフセット変更は表示更新のみで、再レンダリング不要**。

### 境界分割の仕組み

オフセット変換で visual→physical 座標がキャンバス端を跨ぐとき、physical座標にジャンプが発生する（例: x=1023→x=0）。これを放置すると画面を横切る線が描画される。

**対策**: ラップ発生箇所を正確に検出してストロークを分割。visual座標（ラップ前）の `visual + offset` が `size` の倍数を跨いだ箇所でのみ分割する。閾値ベースのヒューリスティックではないため、将来の直線ツール等で長い線分を引いても誤分割されない。

```typescript
// ラップ跨ぎの判定: unwrapped = visual + offset が size の倍数を跨いだか
// floor(prev_unwrapped / size) !== floor(curr_unwrapped / size) → ラップ発生
export function splitStrokeAtWrapBoundary(
  physicalPoints: readonly StrokePoint[],   // ラップ適用後
  visualPoints: readonly Point[],           // ラップ適用前
  offsetX: number, offsetY: number,
  layerWidth: number, layerHeight: number,
): StrokePoint[][];
```

**繋ぎ目の処理**: 分割地点で `drawVariableWidthPath` のcircle描画がキャンバス端をわずかにはみ出す。4コピー合成表示でこのはみ出しが反対側に現れ、セグメント間が自然に接続される（lineWidth ≥ 1px で視覚的にシームレス）。

### Expand（対称展開）との相互作用

Expandは物理座標に対して回転/反転を適用する。展開コピーがキャンバス範囲外に出る場合がある（例: radial-4で隅付近を描画 → 対称コピーが範囲外へ）。オフセットなしならクリップで目立たないが、オフセット使用時は隅への描画が増えるため対処が必要。

**対処**: Expand後にmodulo wrapping + 閾値ベース分割を適用する。

```
expandStrokePoints → wrapPointsToLayer(modulo正規化) → splitExpandedStroke(閾値分割) → draw
```

Expand出力への閾値分割が安全な理由: Expandは等距離変換（回転/反転）なので隣接点間の距離が入力と同じ（≈2px）に保たれる。`size/2`超のジャンプはラップ以外ありえない。入力ストロークの正確なvisual座標ベース分割とは使い分ける。

### SymmetryOverlayのオフセット対応

対称ガイド（SymmetryOverlay）は `layerToScreen(origin, transform)` で表示位置を算出。オフセット適用時、物理座標の原点がvisual上で移動するため、ガイド位置もオフセットに追従させる必要がある。

```typescript
// physical → visual 変換してからScreen座標へ
const visualOrigin = {
  x: ((origin.x - offset.x) % width + width) % width,
  y: ((origin.y - offset.y) % height + height) % height,
};
const screenPos = layerToScreen(visualOrigin, transform);
```

## Doc-First Phases

### Phase 1: API設計・ドキュメント

#### engine パッケージ

**新規型** (`packages/engine/src/types.ts`):
```typescript
export interface WrapOffset {
  readonly x: number;  // ピクセル単位
  readonly y: number;
}
export const DEFAULT_WRAP_OFFSET: WrapOffset = { x: 0, y: 0 };
```

**新規モジュール** (`packages/engine/src/wrap-offset.ts`):
```typescript
// ラップ境界跨ぎでストロークを分割（visual座標からラップ箇所を正確検出）
export function splitStrokeAtWrapBoundary(
  physicalPoints: readonly StrokePoint[],
  visualPoints: readonly Point[],
  offsetX: number, offsetY: number,
  layerWidth: number, layerHeight: number,
): StrokePoint[][];

// WrapOffsetが有効かを判定
export function isWrapOffsetActive(offset: WrapOffset): boolean;

// Expand出力のmodulo wrapping（座標を[0, size)範囲に正規化）
export function wrapPointsToLayer(
  points: readonly StrokePoint[],
  layerWidth: number,
  layerHeight: number,
): StrokePoint[];

// Expand出力用の閾値ベース分割（等距離変換保証があるため閾値で安全）
export function splitExpandedStrokeAtBoundary(
  points: readonly StrokePoint[],
  layerWidth: number,
  layerHeight: number,
): StrokePoint[][];
```

**変更: `appendToCommittedLayer` / `renderPendingLayer`** (`packages/engine/src/incremental-render.ts`):
```typescript
// wrapOffset追加（optional、後方互換）
export function appendToCommittedLayer(
  layer: Layer,
  points: readonly StrokePoint[],
  style: StrokeStyle,
  compiledExpand: CompiledExpand,
  wrapOffset?: WrapOffset,  // NEW
): void;
```
内部フロー（wrapOffset有効時）:
1. `expandStrokePoints` → 展開ストローク生成
2. 各展開ストロークに `wrapPointsToLayer` → 範囲外座標をmodulo正規化
3. `splitExpandedStrokeAtBoundary` → ラップジャンプで分割
4. 各セグメントを `drawVariableWidthPath` で描画

入力ストローク（expand前）の分割は呼び出し側（App層）で `splitStrokeAtWrapBoundary`（visual座標ベース）を適用。

**変更: `renderLayers`** (`packages/engine/src/render.ts`):
```typescript
export interface RenderOptions {
  background?: BackgroundSettings;
  wrapOffset?: WrapOffset;  // NEW
}
```
内部: wrapOffset有効時、各レイヤーをレイヤー領域にクリップした上で4位置に描画:
```
(dx, dy), (dx+W, dy), (dx, dy+H), (dx+W, dy+H)  where dx=-offset.x, dy=-offset.y
```

#### input パッケージ

**新規関数** (`packages/input/src/coordinate.ts`):
```typescript
// visual座標をphysical座標に変換（ラップオフセット適用）
export function applyWrapOffset(
  point: Point,
  offsetX: number,
  offsetY: number,
  layerWidth: number,
  layerHeight: number,
): Point;
// 実装: { x: ((point.x + offsetX) % w + w) % w, y: ((point.y + offsetY) % h + h) % h }
```
inputパッケージはengineに依存しないため、WrapOffset型は使わずプリミティブ引数で受ける。

#### stroke パッケージ

**変更: `StrokeCommand`** (`packages/stroke/src/types.ts`):
```typescript
export interface StrokeCommand {
  // ...既存フィールド
  readonly wrapOffset?: WrapOffset;  // NEW: 描画時のオフセット
}
```

**変更: `createStrokeCommand`** (`packages/stroke/src/session.ts`):
引数に `wrapOffset?: WrapOffset` 追加。

**変更: `replayStrokeCommand`** (`packages/stroke/src/replay.ts`):
保存されたwrapOffsetでフィルタ後の座標を変換→expand→分割→描画。

### Phase 2: 利用イメージレビュー

#### Web App での利用イメージ

**usePointerHandler.ts** - 入力座標にオフセット適用:
```typescript
const layerPoint = screenToLayer(screenPoint, transform);
if (layerPoint) {
  const adjusted = wrapOffset
    ? applyWrapOffset(layerPoint, wrapOffset.x, wrapOffset.y, layerWidth, layerHeight)
    : layerPoint;
  onStrokeStart({ x: adjusted.x, y: adjusted.y, pressure, timestamp });
}
```

**App.tsx** - セッション終了時にオフセットをコマンドに保存:
```typescript
const command = createStrokeCommand(
  inputPoints, compiledFilterPipeline.config, strokeSession.expand,
  strokeStyle.color, strokeStyle.lineWidth,
  strokeStyle.pressureSensitivity, strokeStyle.pressureCurve,
  layerOffset.offset,  // NEW
);
```

**PaintCanvas.tsx** - 表示合成にオフセットを渡す:
```typescript
renderLayers(layers, ctx, dprTransform, { background, wrapOffset });
```

**DebugPanel.tsx** - UI:
```
Layer Offset フォルダ:
  Offset X: 0〜layerWidth（px, step=1）
  Offset Y: 0〜layerHeight（px, step=1）
```

### Phase 3: 実装

1. engine: `WrapOffset`型、`DEFAULT_WRAP_OFFSET`定数
2. engine: `wrap-offset.ts` → `splitStrokeAtWrapBoundary`, `isWrapOffsetActive`, `wrapPointsToLayer`, `splitExpandedStrokeAtBoundary`（テスト含む）
3. input: `applyWrapOffset`（テスト含む）
4. engine: `appendToCommittedLayer`/`renderPendingLayer` に分割ロジック追加
5. engine: `renderLayers` に4コピー合成追加
6. stroke: `StrokeCommand`拡張、`createStrokeCommand`/`replayStrokeCommand`修正
7. web: `useLayerOffset` hook
8. web: `usePointerHandler` にオフセット座標変換追加
9. web: `SymmetryOverlay` にwrapOffset対応追加
10. web: `PaintCanvas`/`DebugPanel`/`App.tsx` 統合
11. ドキュメント更新

### Phase 4: アーキテクトレビュー

- ドキュメント整合性の確認
- `splitStrokeAtBoundary` の境界ケーステスト
- Undo/Redo + 異なるオフセットのストロークが混在した場合の動作検証
- パターンプレビューとの共存確認

## 変更対象ファイル

| パッケージ | ファイル | 変更内容 |
|---|---|---|
| engine | `src/types.ts` | `WrapOffset`, `DEFAULT_WRAP_OFFSET` |
| engine | `src/wrap-offset.ts` (新規) | `splitStrokeAtWrapBoundary`, `isWrapOffsetActive`, `wrapPointsToLayer`, `splitExpandedStrokeAtBoundary` |
| engine | `src/incremental-render.ts` | `wrapOffset?` パラメータ追加、分割ロジック |
| engine | `src/render.ts` | `RenderOptions`拡張、4コピー合成 |
| engine | `src/index.ts` | エクスポート追加 |
| input | `src/coordinate.ts` | `applyWrapOffset` |
| input | `src/index.ts` | エクスポート追加 |
| stroke | `src/types.ts` | `StrokeCommand.wrapOffset?` |
| stroke | `src/session.ts` | `createStrokeCommand` にwrapOffset引数 |
| stroke | `src/replay.ts` | リプレイ時のオフセット適用 |
| web | `src/hooks/useLayerOffset.ts` (新規) | Hook |
| web | `src/hooks/usePointerHandler.ts` | オフセット座標変換 |
| web | `src/components/PaintCanvas.tsx` | renderLayersにwrapOffset渡し |
| web | `src/components/DebugPanel.tsx` | UIフォルダ追加 |
| web | `src/App.tsx` | 統合配線 |
| web | `src/components/SymmetryOverlay.tsx` | wrapOffset対応（ガイド位置調整） |

## 検証方法

1. `pnpm test` - 全テスト通過
2. `pnpm lint && pnpm format` - コードスタイル
3. `pnpm dev` で動作確認:
   - Offset X/Y スライダーでレイヤー表示がラップスクロールすること
   - オフセット状態でストロークを描画し、繋ぎ目を跨いで描画できること
   - オフセットを変更しても既存描画が崩れないこと
   - Undo/Redo が正しく動作すること（異なるオフセットのストローク混在）
   - パターンプレビューが正しく表示されること
   - Expand（対称展開）との併用: オフセット状態でradial展開し四隅に対称描画されること
   - SymmetryOverlayのガイド位置がオフセットに追従すること

## 設計判断（2026-02-08 議論結果）

### 本案は保留: ピクセルシフト案（`plans/2026-02-07-17-30_wrap-offset-pixel-shift.md`）を先に実装する

**判断理由**:
- 本案はvisual/physical座標の二重化がコードベース全体に波及する（~16ファイル変更）
- このライブラリはパターン生成専用ではなく、一部ユースケースのみで利用する機能は局所的に閉じ込めるべき
- ピクセルシフト案は既存の座標系・描画パイプラインに一切変更を加えずに実現可能

**本案の概念的優位性は認める**:
- オフセット変更コストがゼロ
- Expandとのシームレスなラップ連携
- 将来のGPU/WebGL移行との親和性

**将来パターン生成が主要ユースケースとなった場合、本案への移行を再検討する。**

### 議論で判明した本案の未検討事項

| 論点 | 詳細 |
|------|------|
| 分割地点の台形ポリゴン欠落 | `drawVariableWidthPath`はcircle描画だけでなく台形ポリゴン接続も行う。分割地点で台形接続が失われ、微妙な段差が生じる可能性（特に筆圧変化中） |
| パターンプレビューとの視覚的不一致 | 物理キャンバスからタイル生成するため、ユーザーがオフセットで繋ぎ目を中央に持ってきて確認していてもプレビューには反映されない |
| SymmetryOverlayの4コピー表示 | ガイドがキャンバス端付近にある時、ラップした反対側にもガイドを表示すべきか未定義 |
| visual/physicalの型安全性 | ブランド型による座標系の区別方法が未計画。単なるPoint型のまま2つの意味を持つ値が流れるリスク |
| Expand等距離変換の前提の脆弱性 | 閾値ベース分割は等距離変換を前提としているが、将来スケール付きExpandを追加する場合に壊れる |

## 設計メモ

- **パターンプレビュー**: `createPatternTile` は物理キャンバスから直接タイル生成。物理キャンバスのストロークは各自のオフセットで正しい物理位置に描画済みなので、パターンプレビューは変更不要（ただし上記「パターンプレビューとの視覚的不一致」問題あり）
- **Checkpoint**: 物理キャンバスのImageDataを保存。オフセット非依存なので変更不要
- **Expandとの相互作用**: expand後に `wrapPointsToLayer` + `splitExpandedStrokeAtBoundary` を適用。展開コピーが範囲外に出てもmodulo正規化→閾値分割で正しくラップ描画される。2種類の分割を使い分ける理由: 入力ストロークはvisual座標で正確検出（直線ツール対応）、expand出力は等距離変換保証があるため閾値で安全
- **SymmetryOverlay**: ガイド位置をphysical→visual変換してからScreen座標に変換。オフセット変更に追従
- **オフセットはグローバル**: レイヤー単位ではなく表示全体のオフセット（繋ぎ目確認はタイル全体の関心事）
- **ストローク中のオフセット変更**: sessionRef内にオフセットをキャプチャし、ストローク中は固定
